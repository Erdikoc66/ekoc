# -*- coding: utf-8 -*-
"""234327056_Erdi_Koc

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16wGejrxrmlmg2aJF41byk7laCyNBtQ9W

https://colab.research.google.com/drive/16wGejrxrmlmg2aJF41byk7laCyNBtQ9W?usp=sharing
"""

import os

# Dosya adı ve hedef dizin
file_name = "234327056_Erdi_Koc.txt"
target_dir = os.path.join(os.getcwd(), "kaydedilen_dosyalar")

# Hedef dizini oluştur
os.makedirs(target_dir, exist_ok=True)

# Dosya yolunu birleştir
file_path = os.path.join(target_dir, file_name)

# Dosyayı oluştur ve içine yaz
with open(file_path, "w") as file:
    file.write("örnek dosya")

print(f"Dosya başarıyla kaydedildi: {file_path}")

"""## VERI YUKLEME

# Yeni Bölüm

Bu dersin arasınavında , [ChestX-ray8 dataset](https://arxiv.org/abs/1705.02315) veri seti'nden alınan göğüs röntgeni görüntüleriyle çalışacaksınız.
<img src="https://raw.githubusercontent.com/hardik0/AI-for-Medicine-Specialization/master/AI-for-Medical-Diagnosis/Week-1/xray-image.png" alt="U-net Image" width="300" align="middle"/>
"""

# Commented out IPython magic to ensure Python compatibility.
# Import necessary packages
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import os
import seaborn as sns
sns.set()

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/hardik0/AI-for-Medicine-Specialization
# %cd AI-for-Medicine-Specialization/AI-for-Medical-Diagnosis/

# Commented out IPython magic to ensure Python compatibility.
# %ls nih/

# Read csv file containing training datadata
train_df = pd.read_csv("nih/train-small.csv")
# Print first 5 rows
print(f'There are {train_df.shape[0]} rows and {train_df.shape[1]} columns in this data frame')
train_df.head(9)



# Look at the data type of each column and whether null values are present
train_df.info()

print(f"The total patient ids are {train_df['PatientId'].count()}, from those the unique ids are {train_df['PatientId'].value_counts().shape[0]} ")

#sütun adlarını döndürür.
columns = train_df.keys()
columns = list(columns)
print(columns)

#gereksiz sütunları columns listesinden çıkarır ve geriye kalan etiket (label) sütunlarının sayısını ve adlarını yazdırır.
# Remove unnecesary elements
columns.remove('Image')
columns.remove('PatientId')
# Get the total classes
print(f"There are {len(columns)} columns of labels for these conditions: {columns}")

#pozitif etiketlerin sayısını yazdırır.
# Print out the number of positive labels for each class
for column in columns:
    print(f"The class {column} has {train_df[column].sum()} samples")

# resim dosyalarının adlarını numpy dizisi (array) olarak çeker.
images = train_df['Image'].values

# 9 resim dosyası ismi seçer.
random_images = [np.random.choice(images) for i in range(9)]

# resimlerin bulunduğu dizin yolu (img_dir) belirlenir
img_dir = 'nih/images_small/'
#mesaj yazdırır
print('Display Random Images')

# boyutunu ayarlar
plt.figure(figsize=(25,15))

# kaç adet resim var ise ekrana çizdirir örnekde 9 adet var
for i in range(9):
    plt.subplot(3, 3, i + 1)
    img = plt.imread(os.path.join(img_dir, random_images[i]))
    plt.imshow(img, cmap='gray')
    plt.axis('off')

# boşlukları ayarlar görseli düzenler
plt.tight_layout()

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Histogramı çizmek için gamma_corrected'in düzleştirilmiş piksellerini kullan
sns.histplot(gamma_corrected.ravel(), kde=False, color='gray', bins=50,
             label=f'Pixel Mean {np.mean(gamma_corrected):.4f} & Standard Deviation {np.std(gamma_corrected):.4f}')


plt.legend(loc='upper center')
plt.title('Distribution of Pixel Intensities in the gamma_corrected image')
plt.xlabel('Pixel Intensity')
plt.ylabel('# Pixels in Image')

# yazdır
plt.show()

import cv2
import matplotlib.pyplot as plt

# 5, pencere boyutudur; yani 5x5'lik bir pencere kullanarak medyan hesaplanacak
median_filtered = cv2.medianBlur(gamma_corrected, 5)

# (5, 5), çekirdek boyutudur; 5x5'lik bir kernel ile Gauss filtresi uygulanır
gaussian_filtered = cv2.GaussianBlur(gamma_corrected, (5, 5), 0)

# Filtrelenmiş iki resmi yan yana göstermek için matplotlib kullanılır
plt.figure(figsize=(12, 6))

# İlk görsel: Median Filtered Image
plt.subplot(1, 2, 1)
plt.imshow(median_filtered, cmap='gray')
plt.title("Median Filtered Image")

# İkinci görsel: Gaussian Filtered Image
plt.subplot(1, 2, 2)
plt.imshow(gaussian_filtered, cmap='gray')
plt.title("Gaussian Filtered Image")


plt.show()

#Image sütunundan ilk resim dosyasının adını alıyoruz. train_df.Image her bir resmin dosya adı listesini tutuyor ve [0] ile ilk resmi seçiyoruz.
sample_img = train_df.Image[0]
# resim dosyasının tam yolunu oluşturur konumunu belirler  dosyadaki resmi okur
raw_image = plt.imread(os.path.join(img_dir, sample_img))
#beyaz(binary) renkde tonlanması anlamında.
plt.imshow(raw_image, cmap='binary')
plt.colorbar()
#resmin görüntü boyutunu yönünü belirlemede kullanılan kod
plt.title('Raw Chest X Ray Image')
print(f"The dimensions of the image are {raw_image.shape[0]} pixels width and {raw_image.shape[1]} pixels height, one single color channel")
print(f"The maximum pixel value is {raw_image.max():.4f} and the minimum is {raw_image.min():.4f}")
print(f"The mean value of the pixels is {raw_image.mean():.4f} and the standard deviation is {raw_image.std():.4f}")

sns.distplot(raw_image.ravel(),
             label=f'Pixel Mean {np.mean(raw_image):.4f} & Standard Deviation {np.std(raw_image):.4f}', kde=False)
plt.legend(loc='upper center')
plt.title('Distribution of Pixel Intensities in the Image')
plt.xlabel('Pixel Intensity')
plt.ylabel('# Pixels in Image')

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# piksellerin düzleştirilmiş hali
pixel_values = raw_image.ravel()
# resim rengi belirleyebiliriz
sns.histplot(pixel_values, kde=False, color='gray')
# Başlık ve etiketler
plt.title('Pixel Intensity Distribution')
plt.xlabel('Pixel Intensity')
plt.ylabel('Number of Pixels')

# resmi çiz
plt.show()

#numpy kütüphanesini sisteminize yükleyecektir.
#Jupyter Notebook veya IPython içinde dış komutları çalıştırmanıza olanak tanır.
!pip install numpy

from skimage import exposure
import numpy as np
import matplotlib.pyplot as plt

# Kontrast Germe
min_val, max_val = raw_image.min(), raw_image.max()
contrast_stretched = (raw_image - min_val) / (max_val - min_val)
contrast_stretched = (contrast_stretched * 255).astype(np.uint8)

# Histogram Eşitleme
equalized_image = exposure.equalize_hist(contrast_stretched)
equalized_image = (equalized_image * 255).astype(np.uint8)

# Gamma Düzeltmesi
gamma = 1.2
gamma_corrected = np.power(equalized_image / 255.0, gamma) * 255
gamma_corrected = gamma_corrected.astype(np.uint8)

# Görüntüleri ve histogramları çizme
plt.figure(figsize=(18, 10))

# Orijinal Görüntü ve Histogram (Kırmızı tonlarında)
plt.subplot(2, 4, 1)
plt.imshow(np.stack([raw_image, np.zeros_like(raw_image), np.zeros_like(raw_image)], axis=-1))
plt.title('Orijinal Görüntü (Kırmızı)')
plt.colorbar()
plt.subplot(2, 4, 5)
plt.hist(raw_image.ravel(), bins=256, color='gray')
plt.title("Orijinal Görüntü Histogramı")

# Kontrast Gerilmiş Görüntü ve Histogram
plt.subplot(2, 4, 2)
plt.imshow(np.stack([contrast_stretched, np.zeros_like(contrast_stretched), np.zeros_like(contrast_stretched)], axis=-1))
plt.title('Kontrast Gerilmiş Görüntü (Kırmızı)')
plt.colorbar()
plt.subplot(2, 4, 6)
plt.hist(contrast_stretched.ravel(), bins=256, color='gray')
plt.title("Kontrast Gerilmiş Histogramı")

# Histogram Eşitlenmiş Görüntü ve Histogram
plt.subplot(2, 4, 3)
plt.imshow(np.stack([equalized_image, np.zeros_like(equalized_image), np.zeros_like(equalized_image)], axis=-1))
plt.title('Histogram Eşitlenmiş Görüntü (Kırmızı)')
plt.colorbar()
plt.subplot(2, 4, 7)
plt.hist(equalized_image.ravel(), bins=256, color='gray')
plt.title("Eşitlenmiş Histogramı")

# Gamma Düzeltilmiş Görüntü ve Histogram
plt.subplot(2, 4, 4)
plt.imshow(np.stack([gamma_corrected, np.zeros_like(gamma_corrected), np.zeros_like(gamma_corrected)], axis=-1))
plt.title(f'Gamma Düzeltilmiş Görüntü (Gamma={gamma}) (Kırmızı)')
plt.colorbar()
plt.subplot(2, 4, 8)
plt.hist(gamma_corrected.ravel(), bins=256, color='gray')
plt.title("Gamma Düzeltilmiş Histogramı")

plt.tight_layout()
plt.show()

import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt

pixel_values = gamma_corrected.ravel()

# Piksellerin dağılımını histogram olarak çiz
sns.histplot(pixel_values, kde=False, color='black', bins=256, label=f'Pixel Mean {np.mean(gamma_corrected):.4f} & Std Dev {np.std(gamma_corrected):.4f}')
plt.legend(loc='upper right')
plt.title('Gamma Düzeltilmiş Görüntüdeki Piksel Yoğunluklarının Dağılımı')
plt.xlabel('Piksel Yoğunluğu')
plt.ylabel('Görüntüdeki # Piksel')
plt.show()

import cv2  # OpenCV kütüphanesi
import numpy as np  # Sayısal işlemler için
import matplotlib.pyplot as plt  # Görselleştirme için

# Medyan Filtreleme Uygulama
median_filtered = cv2.medianBlur(gamma_corrected, 5)  # 5x5 boyutunda bir çekirdek kullanarak medyan filtreleme uygula

# Gauss Filtreleme Uygulama
gaussian_filtered = cv2.GaussianBlur(gamma_corrected, (5, 5), 0)  # 5x5 boyutunda bir çekirdek ve sıfır standart sapma ile gauss filtreleme uygula

# Sağ görüntüyü kırmızı tonlarında göstermek için:
# 1. Kırmızı kanal dışında diğer kanalları sıfır yapıyoruz (yeşil ve mavi kanalları sıfırlıyoruz)
gaussian_filtered_red = np.zeros_like(np.stack([gaussian_filtered, gaussian_filtered, gaussian_filtered], axis=-1))
gaussian_filtered_red[..., 0] = gaussian_filtered  # Kırmızı kanal (index 0) değerini Gaussian görün

import cv2
import matplotlib.pyplot as plt

# Örnek: Görüntüyü 10 derece döndürme
# Görüntü merkezi (x, y) koordinatları
center = (median_filtered.shape[1] // 2, median_filtered.shape[0] // 2)

# Dönme matrisini oluşturma (10 derece döndürme)
rotation_matrix = cv2.getRotationMatrix2D(center, angle=10, scale=1.0)

# Görüntüyü döndürme
rotated_image = cv2.warpAffine(median_filtered, rotation_matrix, (median_filtered.shape[1], median_filtered.shape[0]))

# Yatay çevrim (Horizontal Flip)
flipped_horizontal = cv2.flip(median_filtered, 1)  # 1, yatay çevrim anlamına gelir

# Sonuçları Görselleştirme
plt.figure(figsize=(12, 6))

# İlk görsel: Döndürülmüş Görüntü
plt.subplot(1, 2, 1)
plt.imshow(rotated_image, cmap='gray')
plt.title("Rotated Image")

# İkinci görsel: Yatay Çevrilmiş Görüntü
plt.subplot(1, 2, 2)
plt.imshow(flipped_horizontal, cmap='gray')
plt.title("Horizontally Flipped Image")


plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt


dft = cv2.dft(np.float32(rotated_image), flags=cv2.DFT_COMPLEX_OUTPUT)
dft_shifted = np.fft.fftshift(dft)

# Maske oluşturma: Merkezdeki düşük frekansları geçiren bir maske
rows, cols = rotated_image.shape
crow, ccol = rows // 2 , cols // 2
mask = np.zeros((rows, cols, 2), np.uint8)
mask[crow-30:crow+30, ccol-30:ccol+30] = 1

# Maskeyi uygula ve ters DFT al
fshift = dft_shifted * mask
f_ishift = np.fft.ifftshift(fshift)
filtered_image = cv2.idft(f_ishift)
filtered_image = cv2.magnitude(filtered_image[:, :, 0], filtered_image[:, :, 1])

# Sonuçları normalize et ve görselleştir
filtered_image = cv2.normalize(filtered_image, None, 0, 255, cv2.NORM_MINMAX)
plt.imshow(filtered_image, cmap='gray')
plt.title("Frequency Domain Filtered Image")
plt.axis("off")
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt
from scipy.ndimage import zoom

# Keskinleştirme (Unsharp Masking) Uygulama
sharpening_kernel = np.array([[-1, -1, -1],
                              [-1,  9, -1],
                              [-1, -1, -1]])
sharpened_image = np.clip(cv2.filter2D(gamma_corrected, -1, sharpening_kernel), 0, 255).astype(np.uint8)

# Bicubic Interpolasyon ile Görüntüyü 2 Kat Büyütme
scale_factor = 2
resized_image = zoom(sharpened_image, scale_factor, order=3)


plt.figure(figsize=(12, 6))


plt.subplot(1, 2, 1), plt.imshow(sharpened_image, cmap='gray'), plt.title("Sharpened Image")


plt.subplot(1, 2, 2), plt.imshow(resized_image, cmap='gray'), plt.title("Interpolated (Upscaled) Image")

plt.tight_layout()
plt.show()